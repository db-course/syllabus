[Назад к главной странице курса](https://github.com/db-course/syllabus)

## 6. Управление транзакциями в СУБД MySQL

### Цель работы

Ознакомление с механизмами изоляции транзакций при параллельном выполнении запросов к одним и тем же данным на различных уровнях изоляции с использованием блокировок и многоверсионности. Получение навыков работы с СУБД MySQL.

### Теоретические сведения

Предварительно ознакомиться: [материалы лекции по изоляции транзакций](https://aksenov.in/guap/db/lectures/doku.php?id=lectures:lecture5).

#### Многоверсионность (на примере MySQL)

Идея многоверсионности (MVCC, Multi-Versioned Concurrency Control) как метода достижения изоляции основана на том факте, что процесс, выполняющий чтение данных (оператор SELECT) заинтересован не столько в их свежести, сколько в их целостности. Следовательно, можно избавиться от необходимости блокировок на чтение, вместо этого предоставляя читающим транзакциям КОПИЮ (снэпшот) последнего, возможно, не самого свежего, но целостного набора запрашиваемых данных.

На уровне REPEATABLE READ каждой транзакции присваивается таймпоинт, после чего она читает свой личный снэпшот целостных данных из журнала транзакций. Добавления, изменения или удаления данных, произведенные параллельными транзакциями с более поздними таймпоинтами, не видны всем операторам текущей транзакции.

На уровне READ COMMITTED каждый оператор SELECT работает со наиболее свежим на момент его старта целостным снэпшотом набора данных. При этом если какая-то другая транзакция после этого изменяет этот набор данных и фиксируется, следующий оператор SELECT получит его новую версию в качестве целостного снэпшота.

Следует понимать, что многоверсионность проявляется только при чтении данных (т.е. отсутствуют S-блокировки, не блокируются зависимости W-R и R-W). При этом запись осуществляется непосредственно в БД, а не в снэпшот, и если возникает зависимость W-W, используются блокировки.

На уровне READ UNCOMMITTED многоверсионность не используется: каждый оператор SELECT читает последнюю (возможно, «грязную») версию данных непосредственно из БД.

Уровень SERIALIZABLE в MySQL эквивалентен уровню REPEATABLE READ с неявным принудительным включением разделяемых блокировок в операторах SELECT.

#### Принудительное включение блокировок

В MySQL есть возможность принудительного включения блокировок на чтение. Это достигается конструкцией SELECT … LOCK IN SHARE MODE.

При этом вне зависимости от уровня изоляции, на существующие в таблице строки, удовлетворяющие условию WHERE оператора SELECT текущей транзакции, накладываются разделяемые блокировки, что:

*   не позволяет текущей транзакции читать данные, измененные другой транзакцией, которая еще не была зафиксирована («грязное чтение», W-R);
*   не позволяет другим транзакциям изменять данные, прочитанные текущей транзакцией (неповторяемое чтение, R-W).

Разница между уровнями изоляции проявляется лишь в способах наложения блокировок. На уровнях READ COMMITTED и READ UNCOMMITTED блокируются только существующие строки, удовлетворяющие условию фильтрации. На уровне REPEATABLE READ используются диапазонные блокировки, что исключает возможность появления фантомов.

#### Общие сведения о MySQL

MySQL – клиент-серверная система управления базами данных. Это означает, что СУБД выполняется в виде процесса и имеет полный доступ к базе данных, тогда как другие приложения при необходимости работать с данными обязаны формировать запросы и отправлять их процессу СУБД.

MySQL имеет в распоряжении несколько движков: InnoDB, MyISAM, XtraDB и другие.

В контексте рассмотрения механизмов управления транзакциями, наибольший интерес представляет ACID-совместимый движок InnoDB, который является который с 2010 года (MySQL 5.5) является движком по умолчанию для таблиц.

### Рекомендации по выполнению лабораторной работы

Задания выполняются с использованием сервера MySQL версии 5.5 или выше. В качестве клиента можно использовать либо поставляемую с сервером утилиту командной строки mysql, либо официальный инструментарий MySQL Workbench, либо стороннее ПО, например, dbForge Studio for MySQL или HeidiSQL. При использовании ПО с графическим интерфейсом пользователя задания выполняются в окне редактора SQL-запросов.

В лабораторной работе необходимо отключить интерактивный режим выполнения запросов, в котором работают все клиенты MySQL. В этом режиме каждый оператор SQL, обрабатываемый клиентом, облекается в отдельную транзакцию, которая автоматически фиксируется после его выполнения (т.н. режим автофискации, autocommit). В лабораторной работе исследуются методы разрешения зависимостей между параллельно (т.е. одновременно) выполняющимися транзакциями, обращающимися к одним и тем же данным, поэтому транзакции должны состоять из нескольких операторов и выполняться продолжительное время.

В интерфейсе командной строки или редакторе SQL начать транзакцию без автофиксации можно выполнив команду BEGIN. В MySQL Workbench можно достичь того же, отключив режим автофиксации транзакций (Auto-Commit Transactions), после чего все выполняемые операторы будут объединены в одну транзакцию, а также станут доступны команды фиксации и отката текущей транзакции.

![](https://github.com/db-course/syllabus/blob/master/img/transmenuwb.png)

Те же элементы управления продублированы на панели инструментов.

![](https://github.com/db-course/syllabus/blob/master/img/transbuttonswb.png)

В dbForge Studio for MySQL по умолчанию также включен режим автофиксации. Можно отключив его, нажав на кнопку начала транзакции или выбрав соответствующий элемент контекстного меню соединения.

![](https://github.com/db-course/syllabus/blob/master/img/transmenudbf.png)

После этого становятся доступны команды фиксации и отката текущей транзакции.

![](https://github.com/db-course/syllabus/blob/master/img/transbuttonsdbf.png)

Для заданий задан уровень изоляции (RU – READ UNCOMMITTED, RC – READ COMMITTED, RR – REPEATABLE READ). Необходимо установить в подключении соответствующий уровень изоляции:

```sql
SET TRANSACTION ISOLATION LEVEL уровень; -- для следующей транзакции

SET SESSION TRANSACTION ISOLATION LEVEL уровень; -- для всех последующих транзакций данного подключения
```

Затем необходимо запустить второе подключение к той же БД. Уровень изоляции можно оставить по умолчанию (в InnoDB это REPEATABLE READ, если не изменялись настройки).

В MySQL Workbench для открытия второго подключения необходимо повторно выполнить команду Open Connection для созданного подключения к базе данных. Оно создастся в соседней вкладке.

![](https://github.com/db-course/syllabus/blob/master/img/secondconnwb.png)

В dbForge Studio for MySQL второе подключение открывается командой дублирования соединения.

![](https://github.com/db-course/syllabus/blob/master/img/secondconndbf.png)

Следует отметить, что в MySQL Workbench по умолчанию включен так называемый "безопасный режим" обновлений и удалений, который заключается в том, что выполняются только те команды UPDATE и DELETE, которые в секции WHERE содержат фильтрацию по ключевому полю. Считается, что это позволит избежать ошибочного изменения или удаления многих строк сразу неопытными пользователями. Поскольку для выполнения работы иногда необходимо фильтровать запросы не по ключевому полю, данный режим следует отключить. Для этого необходимо зайти в меню настроек среды (Edit -> Preferences...) и на вкладке "SQL Editor" снять галочку "Safe Updates".

![](https://github.com/db-course/syllabus/blob/master/img/safemodewb.png)

Параллельно запускаются две транзакции из двух открытых подключений. Первая транзакция T1 (из подключения с уровнем изоляции согласно варианту) производит операции с данными, после чего вторая транзакция T2 также работает с этими данными и так далее. Список действий должен полностью представлять реакцию системы на зависимости между транзакциями.

Для каждого варианта необходимо проанализировать:

1.  Зависимость потерянного обновления

        |    T1   |    T2    |
        |:-------:|:--------:|
        | read(x) |          |
        |         | write(x) |
        | write(x)|          |

2.  Зависимость грязного чтения        

        |    T1   |    T2    |
        |:-------:|:--------:|
        |         | write(x) |
        | read(x) |          |
        |         | write(x) |

3.  Зависимость неповторяемого чтения

        |    T1   |    T2    |
        |:-------:|:--------:|
        | read(x) |          |
        |         | write(x) |
        | read(x) |          |

4.  Зависимость фантомов

        |     T1    |   T2   |
        |:---------:|:------:|
        | filter(t) |        |
        |           | add(t) |
        | filter(t) |        |

Задания MVCC связаны с исследованием механизма многоверсионности для движка InnoDB. При этом транзакцией T1 производятся целостные неблокирующие чтения (в InnoDB – обычный оператор `SELECT`).

Задания LOCK связаны с исследованием реализации принудительных разделяемых блокировок в движке InnoDB. При этом транзакцией T1 производятся блокирующие чтения (в InnoDB – оператор `SELECT … LOCK IN SHARE MODE`).

### Пример 1

MVCC, уровень READ UNCOMMITTED, зависимость потерянного обновления

<table>
    <tr>
        <th>T1</th>
        <th>T2</th>
    </tr>
    <tr>
        <td>
            <pre>
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
BEGIN;
SELECT * FROM t WHERE i = 3;
+------+
|&nbsp;i&nbsp;&nbsp;&nbsp;&nbsp;|
+------+
|&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;|
+------+
1 row in set (0.00 sec)
            </pre>
        </td>
        <td></td>
    </tr>
    <tr>
        <td></td>
        <td>
            <pre>
BEGIN;
UPDATE t SET i=3 WHERE i=2;
Query OK, 1 row affected (0.05 sec)
Rows matched: 1  Changed: 1  Warnings: 0
            </pre>
        </td>
    </tr>
    <tr>
        <td>
            <pre>
UPDATE t SET i=5 WHERE i=2;
ERROR 1205 (HY000): Lock wait timeout exceeded; 
try restarting transaction
            </pre>
        </td>
        <td></td>
    </tr>
    <tr>
        <td></td>
        <td>
            <pre>
COMMIT;
            </pre>
        </td>            
    </tr>
</table>

Вывод: потерянное обновление не допускается, транзакция T1, пытающаяся изменить данные, на которые наложена X-блокировка транзакцией T2, ждет, а затем завершается по таймауту.

### Пример 2

LOCK, уровень READ COMMITTED, зависимость фантомов

<table>
    <tr>
        <th>T1</th>
        <th>T2</th>
    </tr>
    <tr>
        <td>
            <pre>
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
BEGIN;
SELECT * FROM t WHERE i = 3 LOCK IN SHARE MODE;
+------+
|&nbsp;i&nbsp;&nbsp;&nbsp;&nbsp;|
+------+
|&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;|
+------+
1 row in set (0.00 sec)
            </pre>
        </td>
        <td></td>
    </tr>
    <tr>
        <td></td>
        <td>
            <pre>
BEGIN;
INSERT INTO t VALUES (3);
Query OK, 1 row affected (0.00 sec)
            </pre> 
        </td>
    </tr>
    <tr>
        <td>
            <pre>
SELECT * FROM t WHERE i = 3 LOCK IN SHARE MODE;
            </pre>
        </td>
        <td></td>
    </tr>
    <tr>
        <td>
            <pre>
ожидание...
            </pre>
        </td>
        <td></td>
    </tr>
    <tr>
        <td></td>
        <td>
            <pre>
COMMIT;
            </pre>
        </td>            
    </tr>
    <tr>
        <td>
            <pre>
+------+
|&nbsp;i&nbsp;&nbsp;&nbsp;&nbsp;|
+------+
|&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;|
|&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;|
+------+
2 rows in set (0.00 sec)
            </pre>
        </td>
        <td></td>
    </tr>
</table>

Вывод: фантомы допускаются, повторное выполнение запроса транзакцией T1 получает больший набор строк.

## Индивидуальные варианты заданий

Номер варианта вычисляется как ((N - 1) mod 6) + 1, где N – индивидуальный номер, полученный у преподавателя.

Например, индивидуальный номер N = 35. Тогда номер варианта ((N - 1) mod 6) + 1 = ((35 – 1) mod 6) + 1 = (34 mod 6) + 1 = 4 + 1 = 5

<table>
    <tr>
        <th>Вариант</th>
        <th>RU MVCC</th>
        <th>RC MVCC</th>
        <th>RR MVCC</th>
        <th>RC LOCK</th>
        <th>RR LOCK</th>
    </tr>
    <tr>
        <td>1</td>
        <td>+</td>
        <td></td>
        <td></td>
        <td>+</td>
        <td></td>
    </tr>
    <tr>
        <td>2</td>
        <td></td>
        <td>+</td>
        <td></td>
        <td></td>
        <td>+</td>
    </tr>
    <tr>
        <td>3</td>
        <td></td>
        <td></td>
        <td>+</td>
        <td>+</td>
        <td></td>
    </tr>
    <tr>
        <td>4</td>
        <td>+</td>
        <td></td>
        <td></td>
        <td></td>
        <td>+</td>
    </tr>
    <tr>
        <td>5</td>
        <td></td>
        <td>+</td>
        <td></td>
        <td>+</td>
        <td></td>
    </tr>
    <tr>
        <td>6</td>
        <td></td>
        <td></td>
        <td>+</td>
        <td></td>
        <td>+</td>
    </tr>
</table>

### Порядок выполнения

1. Создать с помощью скрипта, полученного в ЛР3, базу данных на сервере MySQL.
1. В двух параллельно запущенных сеансах выполнить набор операторов SQL, позволяющий изучить взаимодействие одновременно выполняющихся транзакций при доступе к одним и тем же данным на заданных в индивидуальном варианте уровнях изоляции.
1. Оформить отчет.

### Содержание отчета

1. Титульный лист.
1. Цель работы.
1. Индивидуальный вариант задания.
1. Снимок экрана реляционной схемы в Microsoft Access.
1. Листинги скриптов SQL пар транзакций, анализирующих наличие/отсутствие проблем параллельного выполнения транзакций на разных уровнях изоляции с использованием разделяемых блокировок или многоверсионностью.
1. Выводы для каждого из листингов.

### Вспомогательные материалы

[Транзакционная модель InnoDB](http://www.mysql.ru/docs/man/InnoDB_transaction_model.html)

### Вопросы к защите

*   Что такое транзакция?
*   Что такое ACID-свойства?
*   Какие существуют методы достижения изоляции?
*   Опишите различия между уровнями изоляции X и Y.
*   В чем заключается принцип многоверсионности?
*   Объясните разницу между эксклюзивными и разделяемыми блокировками.
*   Поясните листинг A.

[Назад к главной странице курса](https://github.com/db-course/syllabus)
